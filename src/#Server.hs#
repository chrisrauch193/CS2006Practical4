module Main where
import Control.Concurrent.STM.TVar
import Control.Monad.STM

import Network.Socket (socketToHandle)
import Network.Simple.TCP
import System.IO
import Control.Concurrent
import Control.Concurrent.Chan

import Board
import Draw
import Input
import AI


--data Board = Board Int

{-mainLoop :: TVar Board -> TVar Col -> Socket -> Chan String -> IO ()
mainLoop firstBoard player1Col sock chan = do
    conn <- accept sock     -- accept a connection and handle it
    forkIO (handleClient firstBoard player1Col conn chan)            -- run our server's logic
    mainLoop firstBoard player1Col sock chan           -- repeat
 
runConn :: (Socket, SockAddr) -> IO ()
runConn (sock, _) = do
    send sock "Hello!\n"
    close sock
-}

main :: IO ()
main = do
  startBoard <- newTVarIO (Board 6 3 [])
  player1Col <- newTVarIO Black
  player2Col <- newTVarIO White
  --serve HostAny "12345" (handleClient boardVar)
  serve HostAny "12345" (handleClient startBoard)
  --serve HostAny "12345" (handleClient startBoard player2Col)
--getVar :: Board -> Int
--getVar (Board x) = x
  --sock <- socket AF_INET Stream 0    -- create socket
  --setSocketOption sock ReuseAddr 1   -- make socket immediately reusable - eases debugging.
  --bind sock (SockAddrInet 4242 iNADDR_ANY)   -- listen on TCP port 4242.
  --listen sock 2                              -- set a max of 2 queued connections
  --chan <- newChan
  --mainLoop startBoard player1Col sock chan                             -- unimplemented

--incrementBoard :: Board -> Board
--incrementBoard (Board x) = (Board (x+1))

--handleClient :: TVar Board -> (Socket, SockAddr) -> IO ()
--handleClient board (s, a) = do
{-handleClient :: TVar Board -> TVar Col -> (Socket, SockAddr) -> Chan String -> IO ()
handleClient startBoard player (s, a) chan = do
  h <- socketToHandle s ReadWriteMode
  clientColour <- readTVarIO player
  firstBoard <- readTVarIO startBoard
  hPutStrLn h ("S_ACCEPT")
  hPutStrLn h (show clientColour)
  hPutStrLn h ("S_UPDATE_BOARD")
  hPutStrLn h (show firstBoard)
  --atomically $ modifyTVar replaceBoard board
  loop $ do
    line <- hGetLine h
    let boardUpdated = read line :: Board
    putStrLn $ "Got message from client " ++ (show boardUpdated)
    hPutStrLn h ("hey bitch: you updated the board to " ++ (show boardUpdated))-}


loop :: IO () -> IO ()
loop a = do
        a
        loop a

replaceBoard :: Board -> Board
replaceBoard newBoard = newBoard

--boardToString :: Board -> String
--boardToString b = (show (size b)) ++ " " ++ (show stringPieces)
--        where
--          piece = pieces b
--          stringPieces = map (showPiece) piece

-- "6 0:0=w 0:1=b"




handleClient :: TVar Board -> TVar Col -> (Socket, SockAddr) -> IO ()
handleClient startBoard player (s, a) = do
  h <- socketToHandle s ReadWriteMode
  clientColour <- readTVarIO player
  firstBoard <- readTVarIO startBoard
  hPutStrLn h ("S_ACCEPT")
  hPutStrLn h (show clientColour)
  hPutStrLn h ("S_UPDATE_BOARD")
  hPutStrLn h (show firstBoard)
  --atomically $ modifyTVar replaceBoard board
  loop $ do
    line <- hGetLine h
    let boardUpdated = read line :: Board
    putStrLn $ "Got message from client " ++ (show boardUpdated)
    hPutStrLn h ("hey bitch: you updated the board to " ++ (show boardUpdated))
    
